
<!DOCTYPE html>

<meta charset="utf8">
<title>Flights</title>

<head>
<script> 
//constants
//mapSizeX = 800
//mapSizeY = 800
mapCoordsX = 0 // center
mapCoordsY = 0 // center
mapScale = 1/40

class TPoint {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
}

var GScaleStep = 1.1

class TView {
     constructor() {
         this.shift = new TPoint(400.0, 400.0) // point of real map at (0,0) of the view
         this.scale = 800 / 50.0
     }
}

var GView = new TView();

class TRealPoint extends TPoint {
}

class TViewPoint extends TPoint {
}

function remap(x, y) {
    
}

timeGlobal = 0
timeRate = 6 // per sec
timeStep = 60 // interval between times (per sec)
frameRate = 30 // per sec

pastCirclesRate = 30 // needed timeRates
pastCirclesCount = 20

flightSize = 7;
circleSize = 2;

function combineArrays(x, y) {
    let a = x.slice();
    for(let i =0; i<y.length; i++) {
        a[a.length] = y[i];
    }
    return a;
}

// pereproverit* wait v samoletah
class TCoords {
    constructor(x,y) {
        this.x = x
        this.y = y
    }
} 

function plus(a,b) {
    return new TCoords(a.x+b.x, a.y+b.y)
} 
function multiply(a, c) {
    return new TCoords(a.x*c, a.y*c) 
}
function cZero() {
    return new TCoords(0,0)
}
function copyTCoords(x) {
    return new TCoords(x.x, x.y)
}
function distance(coordA,coordB) {
    return sqrt(coordA.x*coordB.x + coordA.y*coordB.y);
}



class TFlight {
    constructor(coords, speed, stackDSpeed)       {
        this.coords = copyTCoords(coords)
        this.speed = copyTCoords(speed)
        this.stackDSpeed = stackDSpeed  // [dspeed.x1, .y1 , time1, ...] default - (0,0) 
        this.past = [ ];
        for(let i = 0; i < pastCirclesCount; ++i ) {
        this.past[3*i] = coords.x
        this.past[3*i +1] = coords.y
        this.past[3*i + 2] = timeGlobal
        } // menyat* copipastu
    }
    putCircle() { 
        let a = [ ]
        for(let i = 3; i < this.past.length; ++i) {
            a[(i-3)] = this.past[i]
        }
        a[a.length] = this.coords.x
        a[a.length] = this.coords.y
        a[a.length] = timeGlobal;
        this.past = a.slice();
    }
    
    waitHelper(dSpeed, time) {
        this.coords = plus(this.coords, plus(multiply(this.speed, time),multiply(dSpeed, time*time/2)))
        this.speed = plus(this.speed, multiply(dSpeed, time))
    }
    
    wait(time) {
        let tTime = 0 + time;
        for(let i = 0; i < this.stackDSpeed.length/3; ++i) 
        {
            if(tTime <= this.stackDSpeed[3*i+2]) 
            {
                this.waitHelper(new TCoords(this.stackDSpeed[3*i],this.stackDSpeed[3*i+1]), tTime)
                this.stackDSpeed[3*i+2] -= tTime;
                tTime = 0;
                break;
            }
            this.waitHelper(new TCoords(this.stackDSpeed[3*i],this.stackDSpeed[3*i+1]), this.stackDSpeed[3*i+2])
            this.stackDSpeed[3*i] = 0;
            this.stackDSpeed[3*i+1] = 0;
            tTime -= this.stackDSpeed[3*i+2]
            this.stackDSpeed[3*i+2] = 0
        }
        this.waitHelper(new TCoords(0,0), tTime);
    }
    
    addRoute(x) {
        this.stackDSpeed = combineArrays(this.stackDSpeed, x)
    }
    
    replaceRoute(x) {
        this.stackDSpeed = x.slice()
    }
    
    debugMove(x,y) {
        this.coords = plus(this.coords,new TCoords(x,y)) 
    }
    
    debugBoost(x,y) {
        this.dSpeed = plus(this.dSpeed,new TCoords(x,y))
    }
}

function copyFlight(x) { // menyat pri poyavlenii novih peremennih
    let ans = new TFlight(x.coords, x.speed, x.stackDSpeed)
    ans.past = x.past;
    return ans;
}

//globals
let aha = [-0.293768,0.955877,1.054081,-0.395617,0.918415,1.054251,-0.571914,0.820314,0.867024,-0.672854,0.597532,0.638658,-0.66361,0.242045,0.599258,-0.60355,-0.542954,0.975833,-0.213272,-0.976993,1.67184,0,0,10]
let flight1 = new TFlight(new TCoords(0,0), new TCoords(3,-1), aha)
allFlights = [flight1];
let a = 0
//clickGlobals
clickedFlightID = -1;
predictedRouteExists = false;
predictedRoute = [ ]
 
 
window.onload = main
//window.onclick = clickReaction // onclick(?) 

//----------------------------------------------------------
function addScript(src) {
  var elem = document.createElement("script");
  elem.src = src;
  document.head.appendChild(elem);
}

function jsonp(json) {
    allFlights[json.ctx.id].replaceRoute(json.route);
}

function go(id, coords) {
    var x0 = allFlights[id].coords.x
    var y0 = allFlights[id].coords.y
    var vx0 = allFlights[id].speed.x
    var vy0 = allFlights[id].speed.y

    var x1 = coords.x
    var y1 = coords.y

    var route = []
    var d = Math.sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0))
    route.push( ((x1-x0)/d - vx0) * 1.e4, ((y1-y0)/d - vy0) * 1.e4, 1.e-4)
    route.push(0, 0, d)
    route.push( (-(x1-x0)/d) * 1.e4, (-(y1-y0)/d) * 1.e4, 1.e-4)

    allFlights[id].replaceRoute(route);

    /*
    addScript("http://mss.druxa.ru:28080/compute.jsonp" +
        "?callback=jsonp&ctx={" + '"' + "id" + '"' + ":" + id + "}" + 
        "&x0=" + x0 + 
        "&y0=" + y0 +
        "&vx0=" + vx0 + 
        "&vy0=" + vy0);
    */
} 
//----------------------------------------------------------

function clickReaction(coords) {
    if(x <= mapSizeWidth && y <= mapSizsHeight) {clickMapReaction(x,y); return;} else {clickPanelReaction(x,y);}
}

function clickMapReaction(coords) {
    if(clickedFlightID != -1 && clickRightButton) { // ?????
        // fix preRoute
        clickedFlightID = -1;
        return ;
    }
    if(clickLeftButton) {
        if(clickedFlightID == -1) {
            clickedFlightID = searchFlight(coords)
            return;
        }
        if(clickedFlightID != -1) {
                presictedRoute =  searchRoute(clickedFlightID, coords);
                predictedRouteExists = true;
        }
    }
}
function searchRoute(id, coords) {
    go(id, coords)
}

function clickPanelReaction(coords) {
    if(predictedRouteExists) {
        allFlights[clickedFlightID].replaceRoute(predictedRoute)
         predictedRouteExists = false;
         clickedFlightID = -1;
    }
}

function searchFlight(coords) { // napisano ploho, vivodit pervii samolyot esli nescol'co
    let a = -1;
    for(let i = 0; i < allFlights.length; ++i) {
        if(distance(allFlights[i].coords,coords) < flightSize) {
            a = i;
            break;
        }
    }
    return a;
}

var goods = {};

function main() {
    //прорисовка   
    goods.canvas = initCanvas("main")
    goods.gl = goods.canvas.getContext("2d")

    //goods.programCircles = initShadersCircles(goods.gl)
    //goods.posIndexCircles = goods.gl.getAttribLocation(goods.programCircles, 'pos')
    //goods.fooIndexCircles = goods.gl.getAttribLocation(goods.programCircles, 'foo')
    //goods.gl.useProgram(goods.programCircles)
    
    //let x = Math.sqrt(3)/6
    //goods.positionsCircles = [ 0.,2*x, 1, 0., 0, 1.,
    //                                         0.5,-x, 1, 0.5, 0, 1.,
    //                                        -0.5,-x, 1, 0.5,0.,1.];
    //goods.countCircles = initData(goods.gl, goods.posIndexCircles, goods.fooIndexCircles, goods.positionsCircles)
    
    go(0, new TCoords(10,15));
    drawAll(goods);
    timeGo(goods);
}

function drawDefault(goods) {
    goods.gl.fillStyle = "rgba(0,0,0,1)";
    goods.gl.fillRect(0, 0, goods.canvas.width, goods.canvas.height)
}

//todo: goods method
//todo: color
//todo: circle!
function drawCircle(coords, size, goods) {
    var ctx = goods.gl
    ctx.fillStyle = "rgba(0,255,0,1)";
    ctx.fillRect( Math.floor(coords.x * GView.scale + GView.shift.x - size/2.0), Math.floor(coords.y * GView.scale + GView.shift.y - size/2.0), size, size );
}

function drawAll(goods) {
    drawDefault(goods);

    for(let i = 0; i < allFlights.length; ++i) {
        drawCircle(allFlights[i].coords,flightSize,goods) // parametri dlya korablya 
        
        for(let j = 0; j < pastCirclesCount; ++j) {
            drawCircle(new TCoords(allFlights[i].past[3*j], allFlights[i].past[3*j+1]), circleSize, goods) // params dlya sledov   
        } 
    }   /*
    if(clickedFlightID != -1) {
        drawCircle( allFlights[clickedFlightID].coords, 0.5, goods) //!!!
    } */
    setTimeout(function() {drawAll(goods);}, 1000/ frameRate);
}

function timeGo(goods) {
    for(let i = 0; i<allFlights.length; ++i) {
        allFlights[i].wait(1/timeStep);
    }
    if(timeGlobal % pastCirclesRate == 0) {
        for(let i = 0; i<allFlights.length; ++i) {
            allFlights[i].putCircle();
        }
    }
    timeGlobal += 1.0
    timeRate = Math.exp((timePace + 10) / 5.0) //FIXME: remove +10
    setTimeout( function() {
        timeGo(goods)
    }, 1000 / timeRate)
}

function initData(gl, posIndex, fooIndex, positions) {
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
    gl.bufferData(gl.ARRAY_BUFFER, 
                  new Float32Array(positions), 
                  gl.STATIC_DRAW)
    
    gl.vertexAttribPointer(posIndex,
                           3,
                           gl.FLOAT,
                           false, 
                           24,
                           0)
    gl.enableVertexAttribArray(posIndex)
                         
    gl.vertexAttribPointer(fooIndex,
                           3,
                           gl.FLOAT,
                           false, 
                           24,
                           12)
    gl.enableVertexAttribArray(fooIndex)
                           
    
    let count = positions.length / 6
    return count
}

function drawData(gl,count) {
    gl.drawArrays(gl.TRIANGLES, 0, count)
}

function initCanvas(id) {
    let elem = document.getElementById(id)
    console.log(elem.height, elem.clientHeight, elem.scrollHeight, elem.offsetHeight, elem.innerHeight, elem.outerHeight)
    elem.width = elem.clientWidth
    elem.height = elem.clientHeight
    return elem
}
/////////////SHADERS BEGIN
let VS_SRC_CIRCLE = `
attribute vec3 pos;
attribute vec3 foo;
varying vec3 fs_foo;
varying vec3 fs_pos;

uniform vec2 realPos;
uniform float size;
uniform float scale;

void main() {
    gl_Position = vec4((realPos.x+pos.x*size)/scale,(realPos.y+pos.y*size)/scale,0.,pos.z+1.); 
    fs_foo = foo;
    fs_pos = pos;
}
`
let PS_SRC_CIRCLE = `
precision mediump float;
varying vec3 fs_foo;
varying vec3 fs_pos;

void main() {
    if(fs_pos.x*fs_pos.x + fs_pos.y*fs_pos.y < 0.05) {
   //     gl_FragColor = vec4(fs_foo.r,fs_foo.g,fs_foo.b,1.);
        gl_FragColor = vec4(1.,1.,0.,1.);
    } else {
        discard;
    }
}
`
///////////////SHADERS END

function initShadersCircles(gl) {
    let vs = gl.createShader(gl.VERTEX_SHADER)
    gl.shaderSource(vs, VS_SRC_CIRCLE)
    gl.compileShader(vs)
    
    let vsLog = gl.getShaderInfoLog(vs)
    if (vsLog) {console.log(vsLog);}
    
    let fs = gl.createShader(gl.FRAGMENT_SHADER)
    gl.shaderSource(fs, PS_SRC_CIRCLE)
    gl.compileShader(fs)
    
    let fsLog = gl.getShaderInfoLog(fs)
    if (fsLog) {console.log(fsLog);}
    
    let program = gl.createProgram()
    gl.attachShader(program, vs)
    gl.attachShader(program, fs)
    gl.linkProgram(program)
    
    return program
}
</script>

</head>

<body>
<div style="position: absolute; top: 0; right: 0; bottom: 0; left: 0;">
<!--<table border="solid 1px" height="100%" width="100%">-->
<table style="border: solid 1px; height: 100%; width: 100%">
<tr>
<td id="_main" style="vertical-align: top" width="70%">
<canvas id="main" style="width: 100%; height: 100%; border: 0px; display: block"></canvas>
</td>
<td style="vertical-align: top">


<div>
Time pace: <span id="timePace">0</span>
<input type="button" value="-" onclick="timePaceMinus()"/>
<input type="button" value="+" onclick="timePacePlus()"/>
</div>

<div>
Ship destination: X: <input id="destinationX" type="text" value="0"/> Y: <input id="destinationY" type="text" value="0"/>
<input type="button" value="go" id = "goToDest"/>
</div>
</td>
</tr>
</table>

<script>
    var timePace = 0;
    function syncTimePace() {
        var e = document.getElementById("timePace")
        e.innerHTML = timePace;
    }
    syncTimePace();
    function timePaceMinus() {
        timePace--;
        syncTimePace();
    }
    function timePacePlus() {
        timePace++;
        syncTimePace();
    }
    document.getElementById("goToDest").onclick = function(e) {
        go(0, new TCoords(document.getElementById("destinationX").value, document.getElementById("destinationY").value));
    }

    // view:

    document.getElementById("main").onclick = function(e) {
        let x = (e.offsetX - GView.shift.x) / GView.scale
        let y = (e.offsetY - GView.shift.y) / GView.scale
                        
        document.getElementById("destinationX").value = x
        document.getElementById("destinationY").value = y
    }
    document.getElementById("main").onwheel = function(e) {

        let x = (e.offsetX - GView.shift.x) / GView.scale
        let y = (e.offsetY - GView.shift.y) / GView.scale

        if (e.deltaY < 0) {
            GView.scale *= GScaleStep
        } else {
            GView.scale /= GScaleStep
        }

        GView.shift.x = e.offsetX - x * GView.scale
        GView.shift.y = e.offsetY - y * GView.scale
    }
    document.getElementById("main").onmousemove = function(e) {
        //FIXME: safari does not support e.buttons
        if (e.buttons & 1) {
            let x = (e.offsetX - e.movementX - GView.shift.x) / GView.scale
            let y = (e.offsetY - e.movementY - GView.shift.y) / GView.scale
            GView.shift.x = e.offsetX - x * GView.scale
            GView.shift.y = e.offsetY - y * GView.scale
        }
    }
    document.body.onresize = function(e) {
        initCanvas("main")
    }

</script>
</div>
