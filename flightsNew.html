
<!DOCTYPE html>

<meta charset="utf8">
<title>Flights</title>

<head>
<script> 

class TPoint {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
    copy() {
        return new TPoint(this.x, this.y)
    }
}

let GScaleStep = 1.1

class TView {
     constructor() {
         this.shift = new TPoint(400.0, 400.0) // point of real map at (0,0) of the view
         this.scale = 800 / 10.0
     }
}

let GView = new TView();

let timeGlobal = 0
let timeStep = 50 // interval between times (per sec)
let frameRate = 50 // per sec

let GTraceRate = 0.1
let GTraceDepth = 100
let GShipSize = 7;
let GTraceSize = 2;

function combineArrays(x, y) {
    let a = x.slice();
    for(let i =0; i<y.length; i++) {
        a[a.length] = y[i];
    }
    return a;
}

// pereproverit* wait v samoletah
class TCoords {
    constructor(x,y) {
        this.x = x
        this.y = y
    }
} 

function plus(a,b) {
    return new TCoords(a.x+b.x, a.y+b.y)
} 
function multiply(a, c) {
    return new TCoords(a.x*c, a.y*c) 
}
function cZero() {
    return new TCoords(0,0)
}
function copyTCoords(x) {
    return new TCoords(x.x, x.y)
}
function distance(coordA,coordB) {
    return sqrt(coordA.x*coordB.x + coordA.y*coordB.y);
}

class TState {
    constructor(t, p, v) {
        this.t = t // time
        this.p = p // position
        this.v = v // velocity
    }
}

function arcsinh(z) {
    return Math.log(z + Math.sqrt(1 + z*z))
}

function sinh(x) {
    return 0.5 * (Math.exp(x) - Math.exp(-x))
}


function f2(t) {
    return 1.0 / Math.sqrt(1.0 + t*t)
}

function g2(t) {
    return t / Math.sqrt(1.0 + t*t)
}

function f1(t) {
    return arcsinh(t)
}

function g1(t) {
    return Math.sqrt(1.0 + t*t)
}

function f(t) {
    return t * arcsinh(t) - Math.sqrt(1 + t*t)
}

function g(t) {
    return 0.5 * (t * Math.sqrt(1 + t*t) + arcsinh(t))
}

// do nothing for a period of time
class DefaultRouteLeg {
    constructor(time = 1.0) {
        this.time = 1.0
    }

    init(state) {
        if ("t0" in this) {
            return
        }
        this.t0 = state.t
    }

    pending(state) {
        return this.t0 + this.time - state.t
    }

    update(state, dt) {
        // this.pending(state) >= dt !
        state.p.x += state.v.x * dt
        state.p.y += state.v.y * dt
        state.thrust = new TPoint(0.0, 0.0)
        state.t += dt
    }
}

class TRouteLeg {
    constructor(alpha, theta, taus = null) {
        if (taus == null) {
            taus = AlphaTheta2Tau(alpha, theta)
            // if still null?
            if (taus == null) {
                taus = [0.0, 0.0] // FIXME:!?
            }
        }
        this.tau1 = taus[0]
        this.tau2 = taus[1]
        this.alpha = alpha
        this.theta = theta
        this.cosTheta = Math.cos(theta)
        this.sinTheta = Math.sin(theta)
        this.alpha2 = 1.0 / (alpha * alpha)
        this.alpha1 = 1.0 / alpha
    }

    init(state) {
        if ("t0" in this) {
            return
        }
        //console.log(state.v.x, state.v.y, state.p.x, state.p.y)
        this.tau = this.tau1

        this.t0 = state.t

        //alpha * R^-1 (v) = fg1(tau1) + (u0,v0)
        this.u0 = this.alpha * (state.v.x * this.cosTheta + state.v.y * this.sinTheta) - f1(this.tau1)
        this.v0 = this.alpha * (-state.v.x * this.sinTheta + state.v.y * this.cosTheta) - g1(this.tau1)

        this.x0 = this.alpha * this.alpha * (state.p.x * this.cosTheta + state.p.y * this.sinTheta) - this.u0*this.tau1 - f(this.tau1)
        this.y0 = this.alpha * this.alpha * (-state.p.x * this.sinTheta + state.p.y * this.cosTheta) - this.v0*this.tau1 - g(this.tau1)
    }

    time() {
        return this.alpha1 * (this.tau2 - this.tau1)
    }

    pending(state) {
        return this.t0 + this.time() - state.t
    }

    update(state, dt) {
        let t = state.t
        state.p = FG(t + dt, this)
        state.v = FG1(t + dt, this)
        this.thrust = FG2(t + dt, this)
        state.t += dt
    }
}

function FG2(t ,r) {
    let cos = r.cosTheta
    let sin = r.sinTheta
    let x1 = f2(t)
    let y1 = g2(t)
    let x = cos * x1 - sin * y1
    let y = sin * x1 + cos * y1
    return new TPoint(x, y)
}

function FG1(t, r) {
    let cos = r.cosTheta
    let sin = r.sinTheta
    let a1 = r.alpha1
    let t1 = r.alpha * (t - r.t0) + r.tau1
    let x1 = f1(t1) + r.u0
    let y1 = g1(t1) + r.v0
    let x = a1 * (cos * x1 - sin * y1)
    let y = a1 * (sin * x1 + cos * y1)
    return new TPoint(x, y)
}    

function FG(t, r) {
    let cos = r.cosTheta
    let sin = r.sinTheta
    let a2 = r.alpha2
    let tau = r.alpha * (t - r.t0) + r.tau1
    let x1 = f(tau) + r.u0*tau + r.x0
    let y1 = g(tau) + r.v0*tau + r.y0
    let x = a2 * (cos * x1 - sin * y1)
    let y = a2 * (sin * x1 + cos * y1)
    return new TPoint(x, y)
}


function H(tau, muU) {
    return g1(sinh(arcsinh(tau) + muU)) - g1(tau)
}

// ****** bang-bang solver ********
function Psi2Pho(psi1, psi2, v) {

    let a1 = new TPoint(Math.cos(psi1), Math.sin(psi1))
    let a2 = new TPoint(Math.cos(psi2), Math.sin(psi2))

    let d1 = 1. / (a2.y*a1.x-a1.y*a2.x)

    let pho1 = (- v.x*a2.y + v.y*a2.x) * d1
    let pho2 = (+ v.x*a1.y - v.y*a1.x) * d1

    if (pho1 >= 0.0 && pho2 >= 0.0) {
        let vx = v.x + pho1*a1.x + pho2*a2.x
        let vy = v.y + pho1*a1.y + pho2*a2.y
        console.log("PPP: ", psi1, psi2, pho1, pho2, vx, vy)

        return [pho1, pho2]
    } else {
        return null
    }
}

function Psi2Delta(psi1, psi2, v) {
    let pho = Psi2Pho(psi1, psi2, v)
    if (pho == null) {
        return null
    }
    let t1 = pho[0]
    let t2 = pho[1]
    let a1 = new TPoint(Math.cos(psi1), Math.sin(psi1))
    let a2 = new TPoint(Math.cos(psi2), Math.sin(psi2))
    let v1 = v.x + t1*a1.x
    let u1 = v.y + t1*a1.y
    let x = t1*v.x + 0.5*t1*t1*a1.x + t2*v1 + 0.5*t2*t2*a2.x
    let y = t1*v.y + 0.5*t1*t1*a1.y + t2*u1 + 0.5*t2*t2*a2.y
    return new TPoint(x, y)
}

function Normalize(p) {
    let d1 = 1. / Math.sqrt(p.x*p.x + p.y*p.y)
    return new TPoint(p.x * d1, p.y * d1)
}

function ReLU(x) {
    return x + Math.sqrt(x*x+1.0) // (-inf,+inf) -> (0,+inf)
}

function Variate(a, q, s) {
    let c = Math.sqrt(1. + s*s)
    return new TPoint(
        q * (a.x * c + a.y * s),
        q * (a.y * c - a.x * s) 
    )
}

function blabla(a1) {
    let v = new TPoint(-1,0)
    let a2 = new TPoint( -(a1.x + v.x), -(a1.y + v.y) )

    let t1 = Math.sqrt(Dst2(a1))
    let t2 = Math.sqrt(Dst2(a2))
    let t = t1 + t2

    let p = new TPoint(
        t*v.x + 0.5*t1*a1.x + t2*a1.x + 0.5*t2*a2.x,
        t*v.y + 0.5*t1*a1.y + t2*a1.y + 0.5*t2*a2.y
    )
    GShips[2].state.p = p
}

function BuildBangBangRoute(state, target) {

    let delta = new TPoint(target.x - state.p.x, target.y - state.p.y)
    let v = state.v

    let tApprox = (Dst2(delta) * 4)**(0.25)

    let a1 = new TPoint(
        0.5*(delta.x - v.x * tApprox),
        0.5*(delta.y - v.y * tApprox),
    )

    let foo = function(dx, dy) {
        let a1x = a1.x + dx
        let a1y = a1.y + dy
        let t1 = Math.sqrt(a1x*a1x + a1y*a1y)
        let a2x = -(a1x + v.x)
        let a2y = -(a1y + v.y)
        let t2 = Math.sqrt(a2x*a2x + a2y*a2y)
        let t = t1 + t2

        return new TPoint(
            t*v.x + (0.5*t1 + t2)*a1x + 0.5*t2*a2x,
            t*v.y + (0.5*t1 + t2)*a1y + 0.5*t2*a2y
        )
    }

    let d = Dst2(delta, foo(0,0))

    let dx = 1.
    let dy = 1.

    while (true) {

        let cnt = 0

        while (true) {
            let d2 = Dst2(delta, foo(dx, 0))
            if (d2 < d) {
                a1.x += dx
                d = d2
                dx *= 2
                cnt++
                //console.log("ZZZ:", dx, dy, a1.x, a1.y, d)
            } else {
                if (dx < 1e-6) {
                    //console.log("BBB: ", delta.x, foo(0, 0).x, foo(dx, 0).x, delta.y, foo(0, 0).y, foo(dx, 0).y, d, d2)
                }
                break
            }
        }

        while (true) {
            let d2 = Dst2(delta, foo(-dx, 0))
            if (d2 < d) {
                a1.x -= dx
                d = d2
                dx *= 2
                cnt++
                //console.log("ZZZ:", dx, dy, a1.x, a1.y, d)
            } else {
                if (dx < 1e-6) {
                    //console.log("BBB: ", delta.x, foo(0, 0).x, foo(-dx, 0).x, delta.y, foo(0, 0).y, foo(-dx, 0).y, d, d2)
                }
                break
            }
        }

        if (cnt == 0) {
            dx *= 0.5
        }

        cnt = 0

        while (true) {
            let d2 = Dst2(delta, foo(0, dy))
            if (d2 < d) {
                a1.y += dy
                d = d2
                dy *= 2
                cnt++
                //console.log("ZZZ:", dx, dy, a1.x, a1.y, d)
            } else {
                if (dy < 1e-6) {
                    //console.log("BBB: ", delta.x, foo(0, 0).x, foo(0, dy).x, delta.y, foo(0, 0).y, foo(0, dy).y, d, d2)
                }
                break
            }
        }

        while (true) {
            let d2 = Dst2(delta, foo(0, -dy))
            if (d2 < d) {
                a1.y -= dy
                d = d2
                dy *= 2
                cnt++
                //console.log("ZZZ:", dx, dy, a1.x, a1.y, d)
            } else {
                if (dy < 1e-6) {
                    //console.log("BBB: ", delta.x, foo(0, 0).x, foo(0, -dy).x, delta.y, foo(0, 0).y, foo(0, -dy).y, d, d2)
                }
                break
            }
        }

        if (cnt == 0) {
           dy *= 0.5
        }

        //console.log("XXX:", dx, dy, a1.x, a1.y, d)

        if (dx < 1e-10 && dy < 1e-10) {
            //console.log("QQQ:", dx, dy, d)
            break
        }
    }

    let a2 = new TPoint( -(a1.x + v.x), -(a1.y + v.y) )

    let pho1 = Math.sqrt(Dst2(a1))
    let pho2 = Math.sqrt(Dst2(a2))
    let psi1 = Math.acos(a1.x / pho1)
    if (a1.y < 0) {
        psi1 = -psi1
    }
    let psi2 = Math.acos(a2.x / pho2)
    if (a2.y < 0) {
        psi2 = -psi2
    }

    return [
        new TConstantThrustRouteLeg(psi1, pho1),
        new TConstantThrustRouteLeg(psi2, pho2),
    ]
}

class TConstantThrustRouteLeg {
	constructor(psi, pho) {
        this.psi = psi
        this.a = new TPoint(Math.cos(psi), Math.sin(psi))
        this.pho = pho
    }

    init(state) {
        if ("t0" in this) {
            return 
        }
        this.t0 = state.t
        this.x0 = state.p.x
        this.y0 = state.p.y
        this.v0 = state.v.x
        this.u0 = state.v.y
    }

    time() {
        return this.pho
    }

    pending(state) {
        return this.t0 + this.time() - state.t
    }

    update(state, dt) {
        state.t += dt
        let t = state.t - this.t0
        state.p.x = this.x0 + t*this.v0 + 0.5*t*t*this.a.x
        state.p.y = this.y0 + t*this.u0 + 0.5*t*t*this.a.y
        state.v.x = this.v0 + t*this.a.x
        state.v.y = this.u0 + t*this.a.y
        state.thrust = this.a.copy()
    }
}

// *********************************

//function g1(t) {
//    return Math.sqrt(1.0 + t*t)
//}

//function arcsinh(z) {
//    return Math.log(z + Math.sqrt(1 + z*z))
//}


function AlphaTheta2Tau(alpha, theta) {
    // alpha * Math.cos(theta) == f1(tau2) - f1(tau1)
    // -alpha * Math.sin(theta) == g1(tau2) - g1(tau1)
    let muU = alpha * Math.cos(theta)
    let muV = -alpha * Math.sin(theta)

    // muV = H(tau, muU)
    //let tLo = -Math.exp(muU) * Math.max(0.5, (1.0 - muV) / muU)
    let tLo = -3.0
    while (H(tLo, muU) > muV) {
        tLo = -tLo * tLo
    }
    //console.log("TTT:", tLo, -Math.exp(muU) * Math.max(0.5, (1.0 - muV) / muU))

    let tHi = Math.max(0.0, (1.0 + muV) / muU)

    let dbg = 0

    let delta = tHi - tLo;
    let tau1 = 0.0

    while (tHi - tLo > 1e-6) {
        let t = 0.5 * (tHi + tLo)
        let w = muV + g1(t)
        let h = H(t, muU)
        if (h == Infinity || h == -Infinity) {
            console.log("~~~:", alpha, theta, muU, t, tHi, tLo)
            return null
        }

        if (H(t, muU) > muV) {
        //if (w < 0.0 || Math.abs(arcsinh(t) + muU) > arcsinh(Math.sqrt(Math.abs(w*w - 1.0)))) {
        //if (w < 0.0 || Math.abs(arcsinh(t) + muU) > (Math.sqrt(Math.abs(w*w - 1.0)))) {

        //if ((sinh(arcsinh(t) + muU))**2 > (muV + g1(t))*(muV + g1(t)) - 1.0) {
            tHi = t
        } else {
            tLo = t
        }
        if (tHi - tLo >= delta) {
            console.log("???:", tHi, tLo, tHi - tLo)
            return null
            //dbg = 1
            //break;
        }
        delta = tHi - tLo
        tau1 = t
    }
    //let tau1 = 0.5 * (tLo + tHi)
    let tau2 = sinh(arcsinh(tau1) + muU)
    if (tau2 == Infinity) {
        console.log("!!!:", alpha, theta, tau1)
        return null
    }
    //let tau2 = Math.sqrt((muV + g1(tau1))**2 - 1.0)
    //if (!(Math.abs(arcsinh(tau2) - arcsinh(tau1) - muU) < Math.abs(arcsinh(-tau2) - arcsinh(tau1)))) {
    //    tau2 = -tau2
    //}
    //if (dbg) {
    //    console.log("DDD:", tau1, tau2,  Math.abs(arcsinh(tau2) - arcsinh(tau1) - muU) ,  Math.abs(arcsinh(-tau2) - arcsinh(tau1)) )
    //}



    //console.log(f1(tau2) - f1(tau1), alpha * Math.cos(theta), g1(tau2) - g1(tau1), -alpha * Math.sin(theta), muV, H(tau1, muU))
    return [tau1, tau2]
}

function Foo(lgAlpha, tgTheta) {
    let alpha = (lgAlpha + Math.sqrt(lgAlpha*lgAlpha+1.0)) // Math.exp(lgAlpha)
    let theta = Math.atan(tgTheta)
    let delta = AlphaTheta2Delta(alpha, theta)
    return delta
}

function Dst2(p1, p2 = new TPoint(0,0)) {
    if (p1 == null || p2 == null) {
        return Infinity
    }
    let dx = p1.x - p2.x
    let dy = p1.y - p2.y 
    return dx*dx + dy*dy
}

function Delta2AlphaTheta(delta) {
    let lgAlpha = 0.0
    let tgTheta = 0.0

    let dLgAlpha = 1.0
    let dTgTheta = 1.0

    let d = Dst2(delta, Foo(lgAlpha, tgTheta))

    while (true) {

        let cnt = 0

        while (true) {
            let d2 = Dst2(delta, Foo(lgAlpha + dLgAlpha, tgTheta))
            if (d2 < d) {
                lgAlpha += dLgAlpha
                d = d2
                dLgAlpha *= 2.0
                cnt++
            } else {
                break
            }
        }

        while (true) {
            let d2 = Dst2(delta, Foo(lgAlpha - dLgAlpha, tgTheta))
            if (d2 < d) {
                lgAlpha -= dLgAlpha
                d = d2
                dLgAlpha *= 2.0
                cnt++
            } else {
                break
            }
        }

        if (cnt == 0) {
            dLgAlpha *= 0.5
        }

        cnt = 0

        while (true) {
            let d2 = Dst2(delta, Foo(lgAlpha, tgTheta + dTgTheta))
            if (d2 < d) {
                tgTheta += dTgTheta
                d = d2
                dTgTheta *= 2.0
                cnt++
            } else {
                break
            }
        }

        while (true) {
            let d2 = Dst2(delta, Foo(lgAlpha, tgTheta - dTgTheta))
            if (d2 < d) {
                tgTheta -= dTgTheta
                d = d2
                dTgTheta *= 2.0
                cnt++
            } else {
                break
            }
        }

        if (cnt == 0) {
            dTgTheta *= 0.5
        }
        //console.log("ZZZ:", lgAlpha, dLgAlpha, tgTheta, dTgTheta, d)

        if (dTgTheta < 1e-6 && dLgAlpha < 1e-6) {
            //console.log("QQQ:", lgAlpha, tgTheta, d)
            return [(lgAlpha + Math.sqrt(lgAlpha*lgAlpha+1.0)), Math.atan(tgTheta)]
        }
    }
}

class TShip {
    constructor(state) {
        this.state = state
        this.destination = null // TState
        //this.thrust = new TPoint(0.0, 0.0) // acceleration
        this.route = []
        this.trace = []
        this.nextTrace = this.state.t
    }

    waitStep(dt) {
        let state = this.state
        while (this.route.length) {
            let r = this.route[0]
            r.init(state) // if not yet
            let pending = r.pending(state)
            if (dt >= pending) {
                r.update(state, pending)
                dt -= pending
                this.route.shift()
            } else {
                r.update(state, dt)
                return 
            }
        }
        let r = new DefaultRouteLeg(dt)
        r.update(state, dt)
    }
        
    waitStep2(dt) {
        let state = this.state
        let t = state.t
        state.t += dt
        
        while (this.route.length) {
            let r = this.route[0]
            r.init(state)
            
            if (r.alpha * dt < r.tau2 - r.tau) {
                state.p = FG(t + dt, r)
                state.v = FG1(t + dt, r)
                this.thrust = FG2(t + dt, r)
                r.tau += r.alpha * dt
                t += dt
                dt = 0
                break
            } else {
                let ddt = (r.tau2 - r.tau) / r.alpha
                state.p = FG(t + ddt, r)
                state.v = FG1(t + ddt, r)
                this.thrust = FG2(t + ddt, r) // may omit
                this.route.shift()
                dt -= ddt
                t += ddt
            }
        }

        if (dt > 0) {
            this.state.p.x += dt * this.state.v.x
            this.state.p.y += dt * this.state.v.y
            this.thrust = new TPoint(0.0, 0.0)
        }
    }


    
    waitStep1(dt) {


        let state = this.state

        state.t += dt
        let t = state.t

        state.p.x = t * arcsinh(t) - Math.sqrt(1 + t*t)
        state.p.y = 0.5 * (t * Math.sqrt(1 + t*t) + arcsinh(t))
        
        state.v.x = arcsinh(t)
        state.v.y = Math.sqrt(1 + t*t) 

        this.thrust.x = 1.0 / Math.sqrt(1 + t*t)
        this.thrust.y = t / Math.sqrt(1 + t*t)
    }

    wait(dT) {

        for (;;) {

            if (this.state.t + dT < this.nextTrace) {
                this.waitStep(dT)
                break;
            } else {
                let dt = this.nextTrace - this.state.t
                this.waitStep(dt)
                dT -= dt
                this.trace.push(new TPoint(this.state.p.x, this.state.p.y))
                if (this.trace.length > GTraceDepth) {
                    this.trace.shift()
                }
                this.nextTrace += GTraceRate
            }
        }
    }

    replaceRoute(route) {
        this.route = route
    }
}

let GShips = [
    new TShip(new TState(
        0.0,
        new TPoint(0, 0),
        new TPoint(-1, 0), //u2-u1=1 v2-v1=0
    )),

    /*
    new TShip(new TState(
        0.0,
        new TPoint(-0.5, 0),
        new TPoint(0, 0), //u2-u1=1 v2-v1=0
    )),

    new TShip(new TState(
        0.0,
        new TPoint(0, 0),
        new TPoint(0, 0), //u2-u1=1 v2-v1=0
    ))
    */
]

//GShips[0].replaceRoute([new TConstantThrustRouteLeg(1.2, 2.0), new TConstantThrustRouteLeg(-1.5, 3.0)])

//goAlphaTheta(8.0, 0.6)

//clickGlobals
clickedFlightID = -1;
predictedRouteExists = false;
predictedRoute = [ ]
 
 
window.onload = main
//window.onclick = clickReaction // onclick(?) 

//----------------------------------------------------------
function addScript(src) {
  let elem = document.createElement("script");
  elem.src = src;
  document.head.appendChild(elem);
}

function jsonp(json) {
    GShips[json.ctx.id].replaceRoute(json.route);
}

function goPsi(id, coords) {
    let ship = GShips[id]
    let route = BuildBangBangRoute(ship.state, coords)
    ship.replaceRoute(route)
}

function goAlphaTheta(alpha, theta) {
    GShips[0] = new TShip(new TState(
        0.0,
        new TPoint(0, 0),
        new TPoint(-1, 0), //u2-u1=1 v2-v1=0
    ))
    GShips[0].replaceRoute([new TRouteLeg(alpha, theta)])
}

let GState0 = new TState(
    0.0,
    new TPoint(0, 0),
    new TPoint(-1, 0), //u2-u1=1 v2-v1=0
)

function AlphaTheta2Delta(alpha, theta) {
    let taus = AlphaTheta2Tau(alpha, theta)
    if (taus == null) {
        return null
    }
    let r = new TRouteLeg(alpha, theta, taus)
    r.init(GState0)
    return FG(r.alpha1 * (r.tau2 - r.tau1) + r.t0, r)
}

function gogogo(alpha) {

    drawDefault(goods)
    drawCircle(new TPoint(0,0), GShipSize, goods)

    for (let theta = -1.55; theta <= 1.55; theta += 0.01) {
        let p = AlphaTheta2Delta(alpha, theta)
        //console.log(alpha, theta, p)
        drawCircle(p, GTraceSize, goods)
    }
}

function go2(id, coords, enqueue) {
    let x0 = GShips[id].coords.x
    let y0 = GShips[id].coords.y
    let vx0 = GShips[id].speed.x
    let vy0 = GShips[id].speed.y

    let x1 = coords.x
    let y1 = coords.y

    let route = []

    let d = Math.sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0))
    route.push( ((x1-x0)/d - vx0) * 1.e4, ((y1-y0)/d - vy0) * 1.e4, 1.e-4)
    route.push(0, 0, d)
    route.push( (-(x1-x0)/d) * 1.e4, (-(y1-y0)/d) * 1.e4, 1.e-4)

    //if (enqueue) {
    //    GShips[id].addRoute(route)
    //} else {
        GShips[id].replaceRoute(route)
    //}

    /*
    addScript("http://mss.druxa.ru:28080/compute.jsonp" +
        "?callback=jsonp&ctx={" + '"' + "id" + '"' + ":" + id + "}" + 
        "&x0=" + x0 + 
        "&y0=" + y0 +
        "&vx0=" + vx0 + 
        "&vy0=" + vy0);
    */
} 
//----------------------------------------------------------

function clickReaction(coords) {
    if(x <= mapSizeWidth && y <= mapSizsHeight) {clickMapReaction(x,y); return;} else {clickPanelReaction(x,y);}
}

function clickMapReaction(coords) {
    if(clickedFlightID != -1 && clickRightButton) { // ?????
        // fix preRoute
        clickedFlightID = -1;
        return ;
    }
    if(clickLeftButton) {
        if(clickedFlightID == -1) {
            clickedFlightID = searchFlight(coords)
            return;
        }
        if(clickedFlightID != -1) {
                presictedRoute =  searchRoute(clickedFlightID, coords);
                predictedRouteExists = true;
        }
    }
}
function searchRoute(id, coords) {
    go(id, coords)
}

function clickPanelReaction(coords) {
    if(predictedRouteExists) {
         GShips[clickedFlightID].replaceRoute(predictedRoute)
         predictedRouteExists = false;
         clickedFlightID = -1;
    }
}

function searchFlight(coords) { // napisano ploho, vivodit pervii samolyot esli nescol'co
    let a = -1;
    for(let i = 0; i < GShips.length; ++i) {
        if(distance(GShips[i].coords,coords) < GShipSize) {
            a = i;
            break;
        }
    }
    return a;
}

let goods = {};

function main() {
    //прорисовка   
    goods.canvas = initCanvas("main")
    goods.gl = goods.canvas.getContext("2d")

    //go(0, new TCoords(10,15));
    drawAll(goods);
    timeGo(goods);
}

function drawDefault(goods) {
    goods.gl.fillStyle = "rgba(0,0,0,1)";
    goods.gl.fillRect(0, 0, goods.canvas.width, goods.canvas.height)
}

//todo: goods method
//todo: color
//todo: circle!
function drawCircle(coords, size, goods) {
    let ctx = goods.gl
    ctx.fillStyle = "rgba(0,200,0,1)";
    ctx.fillRect( coords.x * GView.scale + GView.shift.x - size/2.0, coords.y * GView.scale + GView.shift.y - size/2.0, size, size );
}

function drawLine(from, dir, goods) {
    let ctx = goods.gl
    ctx.strokeStyle = "yellow"
    ctx.beginPath();
    ctx.moveTo(from.x * GView.scale + GView.shift.x, from.y * GView.scale + GView.shift.y);
    ctx.lineTo(from.x * GView.scale + GView.shift.x - dir.x * 30, from.y * GView.scale + GView.shift.y - dir.y * 30);
    ctx.stroke();
}


function drawAll(goods) {
    initCanvas("main")
    drawDefault(goods);

    for(let i = 0; i < GShips.length; ++i) {
        let state = GShips[i].state
        drawCircle(state.p, GShipSize, goods) // parametri dlya korablya 
        if (state.thrust) {
            drawLine(state.p, state.thrust, goods)
        }
        
        for(let j = 0; j < GShips[i].trace.length; j++) {
            drawCircle(GShips[i].trace[j], GTraceSize, goods)
        } 
    }
    setTimeout(function() {drawAll(goods);}, 1000 / frameRate);
}

function genHTML(json) {
    if (typeof(json) == "object") {
        let str = "<table style='border: solid 1px'>"
        for (let k in json) {
            str += "<tr><td style='vertical-align: top'>" + k + "</td><td>" + genHTML(json[k]) + "</td></tr>"
        }
        str += "</table>"
        return str
    } else {
        if (Number(json) === json) {
            return json.toFixed(6)
        } else {
            return json
        }
    }
}

function timeGo(goods) {
    for(let i = 0; i<GShips.length; ++i) {
        GShips[i].wait(1/timeStep);
    }

    let dbg = document.getElementById("debug")
    let st = GShips[0].state
    dbg.innerHTML = genHTML(GShips[0])
    // JSON.stringify(GShips[0], null, ' ')

    timeGlobal += 1.0
    let timeRate = Math.exp((timePace + 10) / 5.0) //FIXME: remove +10
    setTimeout( function() {
        timeGo(goods)
    }, 1000 / timeRate)
}

function initCanvas(id) {
    let elem = document.getElementById(id)
    elem.width = elem.clientWidth
    elem.height = elem.clientHeight
    return elem
}
</script>

</head>

<body>
<div style="position: absolute; top: 0; right: 0; bottom: 0; left: 0">

<div style="vertical-align: top; background-color: black; width:70%; height: 100%; float: left">
<canvas id="main" style="width: 100%; height: 100%; border: 0px; display: block; overflow: hidden"></canvas>
</div>

<div style="vertical-align: top; width:30%; height: 100%; float: right">

<div style="border: solid 1px; padding: 2px; margin: 1px"> 
Time pace: <span id="timePace">0</span>
<input type="button" value="-" onclick="timePaceMinus()"/>
<input type="button" value="+" onclick="timePacePlus()"/>
</div>

<div style="border: solid 1px; padding: 2px; margin: 1px">
Ship destination: X: <input id="destinationX" type="text" value="0"/> Y: <input id="destinationY" type="text" value="0"/>
Ship destination: Alpha: <input id="Alpha" type="text" value="8"/> Theta: <input id="Theta" type="text" value="0.6"/>

<input type="button" value="go" id="goToDest"/>
</div>

<div id="debug" style="border: solid 1px; padding: 2px; margin: 1px">
</div>

</div>

</div>

<script>
    let timePace = 0;
    function syncTimePace() {
        let e = document.getElementById("timePace")
        e.innerHTML = timePace;
    }
    syncTimePace();
    function timePaceMinus() {
        timePace--;
        syncTimePace();
    }
    function timePacePlus() {
        timePace++;
        syncTimePace();
    }
    document.getElementById("goToDest").onclick = function(e) {
        //go(0, new TCoords(document.getElementById("destinationX").value, document.getElementById("destinationY").value), e.shiftKey);
        //goAlphaTheta(document.getElementById("Alpha").value, document.getElementById("Theta").value)
        //gogogo(document.getElementById("Alpha").value)
        goPsi(0, new TCoords(document.getElementById("destinationX").value, document.getElementById("destinationY").value))
    }

    // view:

    document.getElementById("main").onclick = function(e) {
        let x = (e.offsetX - GView.shift.x) / GView.scale
        let y = (e.offsetY - GView.shift.y) / GView.scale

        //let alphaTheta = Delta2AlphaTheta(new TPoint(x,y));
        //document.getElementById("Alpha").value = alphaTheta[0]
        //document.getElementById("Theta").value = alphaTheta[1]
        //blabla(new TPoint(x, y))
                        
        document.getElementById("destinationX").value = x
        document.getElementById("destinationY").value = y

        //if (e.ctrlKey) {
            goPsi(0, new TCoords(document.getElementById("destinationX").value, document.getElementById("destinationY").value))
        //}
    }

    document.getElementById("main").onwheel = function(e) {

        let x = (e.offsetX - GView.shift.x) / GView.scale
        let y = (e.offsetY - GView.shift.y) / GView.scale

        if (e.deltaY < 0) {
            GView.scale *= GScaleStep
        } else {
            GView.scale /= GScaleStep
        }

        GView.shift.x = e.offsetX - x * GView.scale
        GView.shift.y = e.offsetY - y * GView.scale

        e.preventDefault()
    }
    document.getElementById("main").onmousemove = function(e) {
        //FIXME: safari does not support e.buttons
        if (e.buttons & 1) {
            let x = (e.offsetX - e.movementX - GView.shift.x) / GView.scale
            let y = (e.offsetY - e.movementY - GView.shift.y) / GView.scale
            GView.shift.x = e.offsetX - x * GView.scale
            GView.shift.y = e.offsetY - y * GView.scale
        }
    }
    document.body.onresize = function(e) {
        initCanvas("main")
    }

</script>
</body>
